from flask import Flask, request, jsonify, g, url_for, abort
from flask_sqlalchemy import SQLAlchemy
from flask_httpauth import HTTPBasicAuth
from pymongo import MongoClient
from flasgger import Swagger
from flask_cors import CORS
from flasgger.utils import swag_from
import nmap
from cve_search import db as cve_db
from cve_search.lib.Config import Configuration
import re
import json
from passlib.apps import custom_app_context as pwd_context
import requests
from JSONEncoder import JSONEncoder
import shlex
import subprocess
import os
import sys
from dateutil.parser import parse as parse_datetime
from xml.sax import make_parser
from cve_handler import CVEHandler
from itsdangerous import (TimedJSONWebSignatureSerializer
                          as Serializer, BadSignature, SignatureExpired)

client = MongoClient('127.0.0.1', 27017)
db = client['cvedb']
vulnscan_collection = db['todos']

#db_mgmt.py
defaultvalue = {}
defaultvalue['cwe'] = "Unknown"

# initialization
app = Flask(__name__)
app.config['SECRET_KEY'] = 'the quick brown fox jumps over the lazy dog'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite'
app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True

# extensions
dbAuth = SQLAlchemy(app)
auth = HTTPBasicAuth()

CORS(app)
Swagger(app)
nm = nmap.PortScanner()

class User(dbAuth.Model):
    __tablename__ = 'users'
    id = dbAuth.Column(dbAuth.Integer, primary_key=True)
    username = dbAuth.Column(dbAuth.String(32), index=True)
    password_hash = dbAuth.Column(dbAuth.String(64))

    def hash_password(self, password):
        self.password_hash = pwd_context.encrypt(password)

    def verify_password(self, password):
        return pwd_context.verify(password, self.password_hash)

    def generate_auth_token(self, expiration=600):
        s = Serializer(app.config['SECRET_KEY'], expires_in=expiration)
        return s.dumps({'id': self.id})

    @staticmethod
    def verify_auth_token(token):
        s = Serializer(app.config['SECRET_KEY'])
        try:
            data = s.loads(token)
        except SignatureExpired:
            return None    # valid token, but expired
        except BadSignature:
            return None    # invalid token
        user = User.query.get(data['id'])
        return user

@auth.verify_password
def verify_password(username_or_token, password):
    # first try to authenticate by token
    user = User.verify_auth_token(username_or_token)
    if not user:
        # try to authenticate with username/password
        user = User.query.filter_by(username=username_or_token).first()
        if not user or not user.verify_password(password):
            return False
    g.user = user
    return True

@app.route('/alive')
def healthz():
    return 'I''m ok, thanks!'

@app.route('/users', methods=['POST'])
def new_user():
    username = request.json.get('username')
    password = request.json.get('password')
    if username is None or password is None:
        abort(400)    # missing arguments
    if User.query.filter_by(username=username).first() is not None:
        abort(400)    # existing user
    user = User(username=username)
    user.hash_password(password)
    dbAuth.session.add(user)
    dbAuth.session.commit()
    return (jsonify({'username': user.username}), 201,
            {'Location': url_for('get_user', id=user.id, _external=True)})

@app.route('/users/<int:id>')
def get_user(id):
    user = User.query.get(id)
    if not user:
        abort(400)
    return jsonify({'username': user.username})

@app.route('/token')
@auth.login_required
def get_auth_token():
    token = g.user.generate_auth_token(600)
    return jsonify({'token': token.decode('ascii'), 'duration': 600})


@app.route('/resource')
@auth.login_required
def get_resource():
    return jsonify({'data': 'Hello, %s!' % g.user.username})

@app.route('/update_db', methods=['POST'])
@auth.login_required
@swag_from('api-docs/update_db.yml')
def update_db():
    """
    GET: Returns the current CVE version on the database
    """

    response = update_collections()
    # runPath = os.path.dirname(os.path.realpath(__file__))
    # process = subprocess.Popen([sys.executable, os.path.join(runPath, "../sbin/db_updater.py"), "-civ"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # out, err = process.communicate()
    # output="%s\n\nErrors:\n%s"%(str(out,'utf-8'),str(err,'utf-8')) if err else str(out,'utf-8')
    # return jsonify({"updateOutput": output, "status": "db_updated"})


    return jsonify(response)

@app.route('/last_scan', methods=['GET'])
@auth.login_required
@swag_from('api-docs/last_scan.yml')
def get_last_scan():
    """
    GET: Returns the current CVE version on the database
    """
    last_id = history_last_id()
    print('last_id before '+str(last_id))
    last_id = last_id != None and last_id or 1
    print('last_id after '+str(last_id))
    cursor = db['history'].find({'id':last_id})

    results = [item for item in cursor]
    return JSONEncoder().encode(results)


# @app.route('/scan_services', methods=['POST'])
# @swag_from('api-docs/scan_services.yml')
def scan_services_by_ip(ip):
    """
    Scan ports and services for a given IP address.
    DATA: results = {'ip': '', 'policy_key': '','results': []}
    POST: Returns an object with ip, policy and a list of results
          containing the services with its versions,
          Returns the CPE name.
    """
    #params = request.get_json()
    params = ip
    nm.scan(str(params['ip']))
    all_ports_detected = nm[params['ip']]['tcp']
    results = {'ip': '', 'policy_key': '','services': []}
    results['ip'] = params['ip']
    results['policy_key'] = params['policy_key']
    for port in all_ports_detected:
        port_scan_result = all_ports_detected[port]
        port_scan_result['port'] = port
        if (int(port) == 443):
            port_scan_result['tls_versions'] = scan_for_tls_support(params['ip'])
        results['services'].append(port_scan_result)

    #return jsonify(results)
    return results

def scan_for_tls_support(ip):
    ssl_results = nm.scan(ip, arguments="-p 443 --script ssl-enum-ciphers")
    ssl_ciphers_results = ssl_results['scan'][ip]['tcp'][443]['script']['ssl-enum-ciphers']
    ssl_tls_version_matches = re.findall('TLSv\d.\d', ssl_ciphers_results, re.DOTALL)
    return ssl_tls_version_matches

# @app.route('/search_vulnerabilities', methods=['POST'])
# @swag_from('api-docs/search_vulnerabilities.yml')
def search_vulnerabilities(service):
    """Scan vulnerabiliies by given CPE name.
    """
    #params = request.get_json()
    #response = {'cpe': params['cpe'], 'vulnerabilities': []}
    response = {'cpe': service['cpe'], 'vulnerabilities': []}
    for item in cve_db.cvesForCPE(service['cpe']):
        vulnerability = {'vulnerability': '','vulnerability_text': '", "score": "'}
        vulnerability['vulnerability'] = item['id']
        vulnerability['vulnerability_text'] = item['summary']
        vulnerability['score'] = item['cvss']
        response['vulnerabilities'].append(vulnerability)
    return response

def save_scan_result(data):
    response = ''
    try:
        r = requests.post('https://api.ersins.com/scan/save', json = data)
        response = r.json()
    except:
        print('There is a erro on saving scan reulst')
    return response

def find_ips():
    try:
        ips = request.get('https://api.ersins.com/scan/find')
    except:
        ips = [{'ip': '127.0.0.1', 'policy_key': '123'}]
    return ips

@app.route('/start_scan', methods=['POST'])
@auth.login_required
@swag_from('api-docs/start_scan.yml')
def start_scan():
    """Scan services and search for vulnerabiliies.
    """
    ips = find_ips()
    responses = []

    services = []
    save_scan_status({'status_list': ips})
    for ip in ips:
        services = scan_services_by_ip(ip)
        for service in services['services']:
            if service['cpe'] != '':
                service['cpe'] = service['cpe'][7:]
                vulnerabilities = search_vulnerabilities(service)
                response_to_save_api = {'ip': '', 'policy_key':'', 'vulnerabilities': []}
                response_to_save_api['ip'] = ip['ip']
                response_to_save_api['policy_key'] = ip['policy_key']
                response_to_save_api['vulnerabilities'] = vulnerabilities['vulnerabilities']
                #Saving scan result to api provided
                save_scan_result(response_to_save_api)
                for vulnerability in vulnerabilities['vulnerabilities']:
                    response = {}
                    response['ip'] = ip['ip']
                    response['policy_key'] = ip['policy_key']
                    response['port'] = service['port']
                    response['service'] = service['name']
                    response['version'] = service['version']
                    response['vulnerability'] = vulnerability['vulnerability']
                    response['vulnerability_text'] = vulnerability['vulnerability_text']
                    response['score'] = vulnerability['score']
                    responses.append(response)
                    save_scan_status(response['ip'])

    print(response_to_save_api)
    try:
        data = {'history_list': responses}
        requests.post('http://0.0.0.0:5000/history_bulk_insert', json=data)
    except:
        print('there is an error trying to history bulk insert')
    return jsonify(responses)


@app.route('/history_bulk_insert', methods=['POST'])
@auth.login_required
@swag_from('api-docs/history_bulk_insert.yml')
def history_bulk_insert():
    """Bulk insert history of scans on database.
    """
    params = request.get_json()
    last_id = history_last_id()
    print('last_id before '+str(last_id))
    last_id = last_id != None and int(last_id) + 1 or 1
    print('last_id after '+str(last_id))
    response = []
    for item in params['history_list']:
        obj = {}
        obj['id'] = last_id
        obj['ip'] = item['ip']
        obj['port'] = item['port']
        obj['score'] = item['score']
        obj['service'] = item['service']
        obj['version'] = item['version']
        obj['vulnerability'] = item['vulnerability']
        obj['vulnerability_text'] = item['vulnerability_text']
        response.append(obj)
    result = db['history'].insert_many(response)
    # return result.inserted_ids
    # return db['history'].insert(obj)
    return '\nsuccess'

def history_last_id():
    """Retrieve last id of scan results history.
    """
    results = db['history'].find_one(sort=[("id", -1)])
    if results != None:
        results = results["id"]
    return results

def update_collections():
    # init parts of the file names to enable looped file download
    file_prefix = "nvdcve-2.0-"
    file_suffix = ".xml.gz"
    file_mod = "modified"
    file_rec = "recent"
    # get the 'modified' file
    getfile = file_prefix + file_mod + file_suffix
    try:
        (f, r) = Configuration.getFile(Configuration.getFeedURL('cve') + getfile)
    except:
        sys.exit("Cannot open url %s. Bad URL or not connected to the internet?"%(Configuration.getFeedURL("cve") + getfile))
    i = cve_db.getInfo("cves")
    last_modified = parse_datetime(r.headers['last-modified'], ignoretz=True)
    if i is not None:
        if last_modified == i['last-modified']:
            print("Not modified")
            return "Not modified"
    cve_db.setColUpdate("cves", last_modified)

    # get your parser on !!
    parser = make_parser()
    ch = CVEHandler()
    parser.setContentHandler(ch)
    parser.parse(f)
    for item in ch.cves:
        # check if the CVE already exists.
        x = cve_db.getCVE(item['id'])
        # if so, update the entry.
        if x:
            if 'cvss' not in item:
                item['cvss'] = None
            if 'cwe' not in item:
                item['cwe'] = defaultvalue['cwe']
            cve_db.updateCVE(item)
        else:
            cve_db.insertCVE(item)
    # get the 'recent' file
    getfile = file_prefix + file_rec + file_suffix
    try:
        (f, r) = Configuration.getFile(Configuration.getFeedURL('cve') + getfile)
    except:
        sys.exit("Cannot open url %s. Bad URL or not connected to the internet?"%(Configuration.getFeedURL("cve") + getfile))
    parser = make_parser()
    ch = CVEHandler()
    parser.setContentHandler(ch)
    parser.parse(f)
    for item in progressbar(ch.cves):
        # check if the CVE already exists.
        x = cve_db.getCVE(item['id'])
        # if so, update the entry.
        if x:
            if args.v:
                print("item found : " + item['id'])
            if 'cvss' not in item:
                item['cvss'] = None
            else:
                item['cvss'] = float(item['cvss'])
            if 'cwe' not in item:
                item['cwe'] = defaultvalue['cwe']
            cve_db.updateCVE(item)
        # if not, create it.
        else:
            cve_db.insertCVE(item)
    return 'success'

@app.route('/last_status', methods=['GET'])
@auth.login_required
# @swag_from('api-docs/last_scan.yml')
def last_status():
    """
    GET: Returns the scan ips status(Pending, Ready)
    """
    last_id = status_last_id()
    last_id = last_id != None and last_id or 1
    cursor = db['status'].find({'id':last_id})

    results = [item for item in cursor]
    return JSONEncoder().encode(results)

def status_last_id():
    """Retrieve last id of scan status.
    """
    print('inside status_last_id')
    print('check status collection exist')
    print("status" in db.collection_names())
    if("status" in db.collection_names()):
        results = db['status'].find_one(sort=[("id", -1)])['id']
    else:
        results = None
    return results

# @app.route('/save_scan_status', methods=['POST'])
# @auth.login_required
# @swag_from('api-docs/history_bulk_insert.yml')
def save_scan_status(params):
    """Insert status of scans on database. Insert one or many records.
    """
    print('inside save_scan_status ')
    # params = request.get_json()
    print(params)
    last_id = status_last_id()
    last_id = last_id != None and int(last_id) + 1 or 1
    print('last_id ', last_id)
    response = []
    for item in params['status_list']:
        obj = {}
        obj['id'] = last_id
        obj['ip'] = item['ip']
        obj['policy_key'] = item['policy_key']
        obj['status'] = 'Pending'
        response.append(obj)
    db['status'].insert_many(response)
    return '\nsuccess'

# @app.route('/update_scan_status', methods=['POST'])
# @auth.login_required
# @swag_from('api-docs/history_bulk_insert.yml')
def update_scan_status(params):
    """Update status of scan to "Ready".
    """
    params = request.get_json()
    status = db['status'].find_one({"ip": params['ip']}, sort=[("id", -1)])
    response = None
    if(status):
        print('update _id:',status['_id'], status['id'], status['status'])
        db['status'].update_one({'_id':status['_id']}, {"$set": {"status":"Ready"}}, upsert=False)
        response = '\success'
    else:
        response = 'Pending status with ip:'+params['ip']+' no found.'
    return response
#if __name__ == '__main__':
    #app.run(debug=True,host='0.0.0.0')
if __name__ == '__main__':
    if not os.path.exists('db.sqlite'):
        dbAuth.create_all()
    app.run(debug=True, host='0.0.0.0')
